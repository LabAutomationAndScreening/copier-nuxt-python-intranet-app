{% raw %}FROM python:{% endraw %}{{ python_version }}{% raw %}-slim-{% endraw %}{{ debian_release_name }}{% raw %}

# docker build -t my-graphql-backend .
# docker run -p {% endraw %}{{ backend_deployed_port_number }}{% raw %}:{% endraw %}{{ backend_deployed_port_number }}{% raw %} my-graphql-backend

SHELL ["/bin/bash", "-o", "pipefail", "-c"]

# tell uv to treat /usr/local as the project env
ENV UV_PROJECT_ENVIRONMENT=/usr/local

COPY --from=ghcr.io/astral-sh/uv:{% endraw %}{{ uv_version }}{% raw %}-python{% endraw %}{{ python_version.split('.')[:2]|join('.') }}{% raw %}-{% endraw %}{{ debian_release_name }}{% raw %}-slim /usr/local/bin/uv /usr/local/bin/uvx /bin/

RUN uv --version

WORKDIR /app

# First just copy in the dependency information for better caching
COPY pyproject.toml uv.lock .python-version ./

RUN uv sync --frozen --no-dev --no-cache-dir

COPY . .

RUN uv pip list --format=columns --verbose

# set sensible defaults (overridable at `docker run`)
ENV API_PORT={% endraw %}{{ backend_deployed_port_number }}{% raw %}

# When deployed with network-mode=host on Rancher Desktop on Windows (for WSL-compatibility), there's no actual port mapping, so we need to have it running on the deployed port within the container itself
EXPOSE {% endraw %}{{ backend_deployed_port_number }}{% raw %}

HEALTHCHECK --interval=5s --timeout=1s --retries=20 --start-period=10s \
  CMD python -c "import urllib.request, os; port = os.environ['API_PORT']; urllib.request.urlopen(f'http://localhost:{int(port)}/api/healthcheck')" || exit 1

# By default, run the entrypoint to serve the GraphQL app
CMD ["sh", "-c", "python src/entrypoint.py --host 0.0.0.0 --port $API_PORT"]{% endraw %}
