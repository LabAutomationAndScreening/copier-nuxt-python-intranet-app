{% raw %}FROM python:{% endraw %}{{ python_version }}{% raw %}-{% endraw %}{{ debian_release_name }}{% raw %} AS builder

# docker build -t my-graphql-backend .
# docker run -p {% endraw %}{{ backend_deployed_port_number }}{% raw %}:{% endraw %}{{ backend_deployed_port_number }}{% raw %} my-graphql-backend

SHELL ["/bin/bash", "-o", "pipefail", "-c"]

# tell uv to treat /usr/local as the project env instead of creating a venv
ENV UV_PROJECT_ENVIRONMENT=/usr/local

COPY --from=ghcr.io/astral-sh/uv:{% endraw %}{{ uv_version }}{% raw %}-python{% endraw %}{{ python_version.split('.')[:2]|join('.') }}{% raw %}-{% endraw %}{{ debian_release_name }}{% raw %} /usr/local/bin/uv /usr/local/bin/uvx /bin/

RUN uv --version

RUN apt-get update && apt-get install -y \
    --no-install-recommends \{% endraw %}{% if install_gcc_in_backend_container_build_phase %}{% raw %}
    "gcc=$(apt-cache madison gcc | awk '{print $3}' | grep '4:12\.2\.' | head -n 1)" \{% endraw %}{% endif %}{% raw %}
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# First just copy in the dependency information for better caching
COPY pyproject.toml uv.lock .python-version ./

RUN uv sync --frozen --no-dev --no-cache-dir

COPY . .

RUN uv pip list --format=columns --verbose

FROM python:{% endraw %}{{ python_version }}{% raw %}-slim-{% endraw %}{{ debian_release_name }}{% raw %}

SHELL ["/bin/bash", "-o", "pipefail", "-c"]

COPY --from=builder /usr/local/lib/python{% endraw %}{{ python_version.split('.')[:2]|join('.') }}{% raw %}/site-packages /usr/local/lib/python{% endraw %}{{ python_version.split('.')[:2]|join('.') }}{% raw %}/site-packages

WORKDIR /app

COPY . .

# set sensible defaults (overridable at `docker run`)
ENV API_PORT={% endraw %}{{ backend_deployed_port_number }}{% raw %}

# When deployed with network-mode=host on Rancher Desktop on Windows (for WSL-compatibility), there's no actual port mapping, so we need to have it running on the deployed port within the container itself
EXPOSE {% endraw %}{{ backend_deployed_port_number }}{% raw %}

HEALTHCHECK --interval=5s --timeout=1s --retries=20 --start-period=10s \
  CMD python -c "import urllib.request, os; port = os.environ['API_PORT']; urllib.request.urlopen(f'http://localhost:{int(port)}/api/healthcheck')" || exit 1

# By default, run the entrypoint to serve the app # the exec form ensures signals from docker compose / k3s are properly forwarded. TODO: have the CLI pick up envvars so that in docker we don't have to use sh
CMD ["sh", "-c", "exec python src/entrypoint.py --host 0.0.0.0 --port $API_PORT"]{% endraw %}
