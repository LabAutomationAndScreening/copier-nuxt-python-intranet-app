{% raw %}import logging
import os
import threading
import time
from importlib.metadata import version
from pathlib import Path

from fastapi import Query
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi_offline import FastAPIOffline
from pydantic import BaseModel
from pydantic import Field

from .fast_api_exception_handlers import register_exception_handlers
from .jinja_constants import HUMAN_FRIENDLY_APP_NAME{% endraw %}{% if backend_uses_graphql %}{% raw %}
from .schema_def import schema
from .strawberry_router import OfflineGraphQLRouter{% endraw %}{% endif %}{% raw %}

logger = logging.getLogger(__name__)
BASE_DIR = Path(__file__).parent.parent
VERSION = version("backend-api")
STATIC_DIR = BASE_DIR / "static"
try:
    app = FastAPIOffline(
        title=HUMAN_FRIENDLY_APP_NAME,
        favicon_url="favicon.ico",
        version=VERSION,
        docs_url="/api-docs",
        static_url="/static/swagger",
    )
except (  # pragma: no cover # This is just logging unexpected errors, and it's very challenging to explicitly unit test
    Exception
):
    logger.exception("Unhandled error instantiating FastAPI object")
    raise


class HealthcheckResponse(BaseModel):
    version: str = Field(description="Version of the application", default="1.0.0")


class ShutdownResponse(BaseModel):
    message: str = Field(
        default="Shutdown request received. Server will exit shortly.",
        description="Message indicating the shutdown request was received",
    )


class NoCacheStaticFiles(StaticFiles):
    """Set cache control headers to prevent caching."""

    @override
    def file_response(  # pragma: no cover # This generally just gets hit by E2E tests
        self, *args: Any, **kwargs: Any
    ) -> Any:
        response = super().file_response(*args, **kwargs)
        response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate"
        response.headers["Pragma"] = "no-cache"
        response.headers["Expires"] = "0"
        return response


@app.get("/api/healthcheck", summary="Check API health", tags=["system"])
def healthcheck(
    *,
    prepend_v: bool = Query(  # pyright: ignore[reportCallInDefaultInitializer] # This seems to be an accepted FastAPI pattern
        default=False, description="Include a 'v' before the version number"
    ),
) -> HealthcheckResponse:
    version_str = VERSION
    if prepend_v:
        version_str = f"v{VERSION}"
    return HealthcheckResponse(version=version_str)


@app.get("/api/shutdown", summary="Shut down the server", tags=["system"])
def shutdown() -> ShutdownResponse:
    logger.info("Server shutdown request received")

    def do_shutdown():
        time.sleep(0.1)  # Give time for the request to return a success response
        logger.info("Server is shutting down.")
        os._exit(
            0
        )  # sys.exit just causes an internal server error, it doesn't actually stop the server. So a hard exit is needed

    threading.Thread(target=do_shutdown, name="execute_shutdown").start()
    return ShutdownResponse()


try:
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # Super permissive CORS setting since this is for intranet
        allow_credentials=True,
        allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        allow_headers=["*"],
    ){% endraw %}{% if backend_uses_graphql %}{% raw %}

    graphql_app = OfflineGraphQLRouter(schema)
    app.include_router(graphql_app, prefix="/api/graphql"){% endraw %}{% endif %}{% raw %}
    app.mount(
        "/", NoCacheStaticFiles(directory=STATIC_DIR, html=True), name="static"
    )  # this needs to go after any defined routes so that the routes take precedence
    register_exception_handlers(app)
except (  # pragma: no cover # This is just logging unexpected errors, and it's very challenging to explicitly unit test
    Exception
):
    logger.exception("Unhandled error")
    raise{% endraw %}
