{% raw %}import logging

import pytest
from backend_api import configure_logging
from backend_api.app_def import app
from fastapi import FastAPI

from .snapshot import snapshot_json{% endraw %}{% if configure_vcrpy %}{% raw %}
from .vcrpy_fixtures import pytest_recording_configure
from .vcrpy_fixtures import vcr_config{% endraw %}{% endif %}{% raw %}

_imported_fixtures = (snapshot_json,{% endraw %}{% if configure_vcrpy %}{% raw %} pytest_recording_configure, vcr_config{% endraw %}{% endif %}{% raw %})
logger = logging.getLogger(__name__)


@pytest.fixture(autouse=True, scope="session")
def configure_log():
    configure_logging(log_filename_prefix="logs/pytest-")


def _get_all_state_attributes(app: FastAPI) -> set[str]:
    return set(
        app.state._state.keys()  # noqa: SLF001 # yes this isn't great, but not sure of another way to be able to keep the state from bleeding over between tests. given the implementation it seems unlikely that _state would change in future versions
    )


@pytest.fixture(autouse=True)
def reset_app_state():
    """Reset app state between tests by removing dynamically added attributes."""
    original_attrs = _get_all_state_attributes(app)

    yield

    current_attrs = _get_all_state_attributes(app)
    added_attrs = current_attrs - original_attrs
    for attr in added_attrs:
        delattr(app.state, attr){% endraw %}
