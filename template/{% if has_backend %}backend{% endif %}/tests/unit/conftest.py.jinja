{% raw %}import logging

import pytest
from backend_api import configure_logging
from backend_api.app_def import app
from fastapi import FastAPI

{% endraw %}{% if configure_python_asyncio %}{% raw %}from .asyncio_fixtures import fail_on_background_task_errors
{% endraw %}{% endif %}{% raw %}from .snapshot import snapshot_json{% endraw %}{% if configure_vcrpy %}{% raw %}
from .vcrpy_fixtures import pytest_recording_configure
from .vcrpy_fixtures import vcr_config{% endraw %}{% endif %}{% raw %}

# fmt: off # this line has a variety of things put into it by Jinja syntax, so disabling autoformatting to avoid conflicts
_imported_fixtures = [snapshot_json{% endraw %}{% if configure_vcrpy %}{% raw %}, pytest_recording_configure, vcr_config{% endraw %}{% endif %}{% raw %}{% endraw %}{% if configure_python_asyncio %}{% raw %}, fail_on_background_task_errors{% endraw %}{% endif %}{% raw %}]
# fmt: on
logger = logging.getLogger(__name__)


@pytest.fixture(autouse=True, scope="session")
def configure_log():
    configure_logging(log_filename_prefix="logs/pytest-")


def _get_all_state_attributes(app: FastAPI) -> set[str]:
    return set(
        app.state._state.keys()  # noqa: SLF001 # yes this isn't great, but not sure of another way to be able to keep the state from bleeding over between tests. given the implementation it seems unlikely that _state would change in future versions
    )


@pytest.fixture(autouse=True)
def reset_app_state():
    """Reset app state between tests by removing dynamically added attributes."""
    original_attrs = _get_all_state_attributes(app)

    yield

    current_attrs = _get_all_state_attributes(app)
    added_attrs = current_attrs - original_attrs
    for attr in added_attrs:
        delattr(app.state, attr){% endraw %}
