name: Build Docker Image

on:
  workflow_call:
    inputs:
      repository:
        description: 'Docker repository'
        type: string
        required: true
      image_name:
        description: 'Docker image name'
        type: string
        required: true
      tag:
        description: 'Docker image tag'
        type: string
        required: true
      context:
        description: 'Build context path'
        type: string
        required: false
        default: './'
      push-role-name:
        type: string
        description: What's the IAM role name to use for Pushing to the ECR?
        required: false
        default: no-push
      save-as-artifact:
        type: boolean
        description: 'Should the image be saved as an artifact?'
        required: false
        default: false

permissions:
    id-token: write
    contents: write # needed for mutex

jobs:
  build-image:
    name: Build Docker Image
    runs-on: ubuntu-24.04
    steps:
      - name: Parse ECR URL
        if: ${{ inputs.push-role-name != 'no-push' }}
        id: parse_ecr_url
        run: |
          ECR_URL="${{ inputs.repository}}"

          # Extract the AWS Account ID, which is the first field
          AWS_ACCOUNT_ID=$(echo "$ECR_URL" | cut -d. -f1)

          # Extract the AWS Region, which is the fourth field in the URL structure
          AWS_REGION=$(echo "$ECR_URL" | cut -d. -f4)

          # Set the outputs for use in later steps
          echo "aws_account_id=${AWS_ACCOUNT_ID}" >> "$GITHUB_OUTPUT"
          echo "aws_region=${AWS_REGION}" >> "$GITHUB_OUTPUT"
        shell: bash

      - name: Checkout code
        uses: actions/checkout@v4.2.2

      - name: OIDC Auth for ECR
        if: ${{ inputs.push-role-name != 'no-push' }}
        uses: aws-actions/configure-aws-credentials@v4.1.0
        with:
          role-to-assume: arn:aws:iam::${{ steps.parse_ecr_url.outputs.aws_account_id }}:role/${{ inputs.push-role-name }}
          aws-region: ${{ steps.parse_ecr_url.outputs.aws_region }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2.0.1

      - name: Set up mutex # Github concurrency management is horrible, things get arbitrarily cancelled if queued up. So using mutex until github fixes itself. When multiple jobs are modifying cache at once, weird things can happen.  possible issue is https://github.com/actions/toolkit/issues/658
        if: ${{ inputs.push-role-name != 'no-push' }}
        uses: ben-z/gh-action-mutex@1ebad517141198e08d47cf72f3c0975316620a65 # v1.0.0-alpha.10
        with:
          branch: mutex-${{ inputs.repository }}-${{ inputs.image_name }}
        timeout-minutes: 30 # this is the amount of time this action will wait to attempt to acquire the mutex lock before failing, e.g. if other jobs are queued up in front of it

      # TODO: check if tag already exists

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3.10.0
        with:
          version: v0.22.0

      - name: Build Docker Image
        uses: docker/build-push-action@v6.15.0
        with:
          context: ${{ inputs.context }}
          push: ${{ inputs.push-role-name != 'no-push' }}
          load: ${{ inputs.save-as-artifact }} # make the image available later for the `docker save` step
          tags: ${{ inputs.repository }}/${{ inputs.image_name }}:${{ inputs.tag }}

      - name: Save Docker Image as tar
        if: ${{ inputs.save-as-artifact }}
        run: docker save -o ${{ inputs.image_name }}.tar ${{ inputs.repository }}/${{ inputs.image_name }}:${{ inputs.tag }}

      - name: Upload Docker Image Artifact
        if: ${{ inputs.save-as-artifact }}
        uses: actions/upload-artifact@v4.6.2
        with:
          name: ${{ inputs.image_name }}
          path: ${{ inputs.image_name }}.tar
          if-no-files-found: error
